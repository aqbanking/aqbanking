<?xml?>

<tm2>
  <type id="AB_TRANSACTION" type="pointer">
    <descr>
      This type contains all important information about transactions.
      All text fields are in UTF-8.
    </descr>

    <lang id="c">
      <identifier>AB_TRANSACTION</identifier>
      <prefix>AB_Transaction</prefix>

      <baseFileName>transaction</baseFileName>

      <flags>
        with_hash
        with_xml
        with_db
        with_list1
        with_list2
        with_constlist2
        with_refcount
      </flags>

      <headers>
        <header type="sys" loc="pre">aqbanking/error.h</header>
        <header type="sys" loc="pre">aqbanking/types/value.h</header>

        <header type="sys" loc="pre">gwenhywfar/gwendate.h</header>

        <header type="sys" loc="pre">gwenhywfar/mdigest.h</header>
        <header type="sys" loc="pre">gwenhywfar/text.h</header>
        <header type="sys" loc="pre">gwenhywfar/buffer.h</header>
        <header type="sys" loc="pre">gwenhywfar/db.h</header>
        <header type="sys" loc="pre">gwenhywfar/debug.h</header>

<!--
        <header type="sys" loc="post">aqbanking/transactionfns.h</header>
        <header type="local" loc="codeEnd">transactionfns.c</header>
-->
      </headers>

      <inlines>

        <inline loc="end" access="public">
          <typeFlagsMask>  with_hash </typeFlagsMask>
          <typeFlagsValue> with_hash </typeFlagsValue>
          <content>
             $(api) int $(struct_prefix)_GenerateHash($(struct_type) *st);
          </content>
        </inline>

        <inline loc="code">
          <typeFlagsMask>  with_hash </typeFlagsMask>
          <typeFlagsValue> with_hash </typeFlagsValue>
          <content>
             int $(struct_prefix)_GenerateHash($(struct_type) *st){
               GWEN_BUFFER *buf;
               int rv;
               GWEN_MDIGEST *md;

               assert(st);

               buf=GWEN_Buffer_new(0, 256, 0, 1);
               $(struct_prefix)_toHashString(st, buf);

               md=GWEN_MDigest_Rmd160_new();

               rv=GWEN_MDigest_Begin(md);
               if (rv&lt;0) {
                 DBG_INFO(AQBANKING_LOGDOMAIN, "here (%d)", rv);
                 GWEN_MDigest_free(md);
                 GWEN_Buffer_free(buf);
                 return rv;
               }

               rv=GWEN_MDigest_Update(md,
                    (const uint8_t*)GWEN_Buffer_GetStart(buf),
                    GWEN_Buffer_GetUsedBytes(buf));
               if (rv&lt;0) {
                 DBG_INFO(AQBANKING_LOGDOMAIN, "here (%d)", rv);
                 GWEN_MDigest_free(md);
                 GWEN_Buffer_free(buf);
                 return rv;
               }

               rv=GWEN_MDigest_End(md);
               if (rv&lt;0) {
                 DBG_INFO(AQBANKING_LOGDOMAIN, "here (%d)", rv);
                 GWEN_MDigest_free(md);
                 GWEN_Buffer_free(buf);
                 return rv;
               }

               GWEN_Buffer_Reset(buf);

               rv=GWEN_Text_ToHexBuffer((const char*)GWEN_MDigest_GetDigestPtr(md),
                                        GWEN_MDigest_GetDigestSize(md),
                                        buf,
                                        0, 0, 0);
               if (rv&lt;0) {
                 DBG_INFO(AQBANKING_LOGDOMAIN, "here (%d)", rv);
                 GWEN_MDigest_free(md);
                 GWEN_Buffer_free(buf);
                 return rv;
               }
               GWEN_MDigest_free(md);

               $(struct_prefix)_SetHash(st, GWEN_Buffer_GetStart(buf));
               GWEN_Buffer_free(buf);

               return 0;
             }
          </content>
        </inline>


        <inline loc="end" access="public">
          <typeFlagsMask></typeFlagsMask>
          <typeFlagsValue></typeFlagsValue>
          <content>
             /**                                                                                              \n
              * Check whether a transaction matches the given type and command.                               \n
              *                                                                                               \n
              * @return 1 if match, 0 otherwise                                                               \n
              * @param tl pointer to the list to search                                                       \n
              * @param ty transaction type, if 0 then this is not checked                                     \n
              * @param cmd command, if -1 then any non-zero command matches, if 0 then this is not checked    \n
             */                                                                                               \n
             $(api) int $(struct_prefix)_MatchTypeAndCommand(const $(struct_type) *t, int ty, int cmd);
          </content>
        </inline>

        <inline loc="code">
          <typeFlagsMask></typeFlagsMask>
          <typeFlagsValue></typeFlagsValue>
          <content>
             int $(struct_prefix)_MatchTypeAndCommand(const $(struct_type) *t, int ty, int cmd) {
               int match=1;
  
               if (match) {
                 if ((ty &gt; AB_Transaction_TypeNone)  &amp;&amp; (t-&gt;type!=ty)) {
                   return 0;
                 }
               }
  
               if (match) {
                 if ((cmd &gt; AB_Transaction_CommandNone) &amp;&amp; (t-&gt;command!=cmd)) {
                   return 0;
                 }
               }
  
               if (match) {
                 if ((cmd &lt; AB_Transaction_CommandNone) &amp;&amp; (t-&gt;command &lt;= AB_Transaction_CommandNone)) {
                   return 0;
                 }
               }
               /* matches */
               return 1;
             }
          </content>
        </inline>





        <inline loc="end" access="public">
          <typeFlagsMask>with_list</typeFlagsMask>
          <typeFlagsValue>with_list</typeFlagsValue>
          <content>
             /**                                                                                              \n
              * Find first transaction in a list which matches the given type and command.                    \n
              *                                                                                               \n
              * @return Entry matching the description (or NULL if none)                                      \n
              * @param tl pointer to the list to search                                                       \n
              * @param ty transaction type, if 0 then this is not checked                                     \n
              * @param cmd command, if -1 then any non-zero command matches, if 0 then this is not checked    \n
             */                                                                                               \n
             $(api) $(struct_type) * $(struct_prefix)_List_FindFirstByType(const $(struct_type)_LIST *tl, int ty, int cmd);
          </content>
        </inline>

        <inline loc="code">
          <typeFlagsMask>with_list</typeFlagsMask>
          <typeFlagsValue>with_list</typeFlagsValue>
          <content>
             $(struct_type) * $(struct_prefix)_List_FindFirstByType(const $(struct_type)_LIST *tl, int ty, int cmd) {
               if (tl) {
                 $(struct_type) *t;

                 t=$(struct_prefix)_List_First(tl);
                 while(t) {
                   if ($(struct_prefix)_MatchTypeAndCommand(t, ty, cmd))
                     return t;
                   t=$(struct_prefix)_List_Next(t);
                 }
               }
               return NULL;
             }
          </content>
        </inline>


        <inline loc="end" access="public">
          <typeFlagsMask>with_list</typeFlagsMask>
          <typeFlagsValue>with_list</typeFlagsValue>
          <content>
             /**                                                                                              \n
              * Find next transaction in a list which matches the given type and command.                     \n
              *                                                                                               \n
              * @return Entry matching the description (or NULL if none)                                      \n
              * @param t pointer to the previous match (as returned by $(struct_prefix)_List_FindFirstByType) \n
              * @param ty transaction type, if 0 then this is not checked                                     \n
              * @param cmd command, if -1 then any non-zero command matches, if 0 then this is not checked    \n
             */                                                                                               \n
             $(api) $(struct_type) * $(struct_prefix)_List_FindNextByType(const $(struct_type) *t, int ty, int cmd);
          </content>
        </inline>

        <inline loc="code">
          <typeFlagsMask>with_list</typeFlagsMask>
          <typeFlagsValue>with_list</typeFlagsValue>
          <content>
             $(struct_type) * $(struct_prefix)_List_FindNextByType(const $(struct_type) *tPrev, int ty, int cmd) {
               if (tPrev) {
                 $(struct_type) *t;

                 t=$(struct_prefix)_List_Next(tPrev);
                 while(t) {
                   if ($(struct_prefix)_MatchTypeAndCommand(t, ty, cmd))
                     return t;
                   t=$(struct_prefix)_List_Next(t);
                 }
               }
               return NULL;
             }
          </content>
        </inline>



        <inline loc="end" access="public">
          <typeFlagsMask>with_list</typeFlagsMask>
          <typeFlagsValue>with_list</typeFlagsValue>
          <content>
             /**                                                                                              \n
              * Remove matching transactions from the given list                                              \n
              *                                                                                               \n
              * @return Number of transactions removed from the list                                          \n
              * @param tl pointer to the list to search                                                       \n
              * @param ty transaction type, if 0 then this is not checked                                     \n
              * @param cmd command, if -1 then any non-zero command matches, if 0 then this is not checked    \n
             */                                                                                               \n
             $(api) int $(struct_prefix)_List_RemoveByType($(struct_type)_LIST *tl, int ty, int cmd);
          </content>
        </inline>

        <inline loc="code">
          <typeFlagsMask>with_list</typeFlagsMask>
          <typeFlagsValue>with_list</typeFlagsValue>
          <content>
             int $(struct_prefix)_List_RemoveByType($(struct_type)_LIST *tl, int ty, int cmd) {
               int cntRemoved=0;

               if (tl) {
                 $(struct_type) *t;

                 t=$(struct_prefix)_List_First(tl);
                 while(t) {
                   $(struct_type) *tNext;

                   tNext=$(struct_prefix)_List_Next(t);

                   if ($(struct_prefix)_MatchTypeAndCommand(t, ty, cmd)) {
                     $(struct_prefix)_List_Del(t);
                     $(struct_prefix)_free(t);
                     cntRemoved++;
                   }

                   t=tNext;
                 }
               }
               return cntRemoved;
             }
          </content>
        </inline>



        <inline loc="end" access="public">
          <typeFlagsMask>with_list</typeFlagsMask>
          <typeFlagsValue>with_list</typeFlagsValue>
          <content>
             /**                                                                                              \n
              * Keep matching transactions in the given list and delete others.                               \n
              *                                                                                               \n
              * @return Number of transactions removed from the list                                          \n
              * @param tl pointer to the list to search                                                       \n
              * @param ty transaction type, if 0 then this is not checked                                     \n
              * @param cmd command, if -1 then any non-zero command matches, if 0 then this is not checked    \n
             */                                                                                               \n
             $(api) int $(struct_prefix)_List_KeepByType($(struct_type)_LIST *tl, int ty, int cmd);
          </content>
        </inline>

        <inline loc="code">
          <typeFlagsMask>with_list</typeFlagsMask>
          <typeFlagsValue>with_list</typeFlagsValue>
          <content>
             int $(struct_prefix)_List_KeepByType($(struct_type)_LIST *tl, int ty, int cmd) {
               int cntRemoved=0;

               if (tl) {
                 $(struct_type) *t;

                 t=$(struct_prefix)_List_First(tl);
                 while(t) {
                   $(struct_type) *tNext;

                   tNext=$(struct_prefix)_List_Next(t);

                   if (! $(struct_prefix)_MatchTypeAndCommand(t, ty, cmd)) {
                     $(struct_prefix)_List_Del(t);
                     $(struct_prefix)_free(t);
                     cntRemoved++;
                   }

                   t=tNext;
                 }
               }
               return cntRemoved;
             }
          </content>
        </inline>



        <inline loc="end" access="public">
          <typeFlagsMask>with_list</typeFlagsMask>
          <typeFlagsValue>with_list</typeFlagsValue>
          <content>
             $(api) int $(struct_prefix)_List_CountByType(const $(struct_type)_LIST *tl, int ty, int cmd);
          </content>
        </inline>

        <inline loc="code">
          <typeFlagsMask>with_list</typeFlagsMask>
          <typeFlagsValue>with_list</typeFlagsValue>
          <content>
             int $(struct_prefix)_List_CountByType(const $(struct_type)_LIST *tl, int ty, int cmd) {
               int count=0;

               if (tl) {
                 $(struct_type) *t;

                 t=$(struct_prefix)_List_First(tl);
                 while(t) {
                   if ($(struct_prefix)_MatchTypeAndCommand(t, ty, cmd))
                     count++;
                   t=$(struct_prefix)_List_Next(t);
                 }
               }
               return count;
             }
          </content>
        </inline>


        <inline loc="end" access="public">
          <typeFlagsMask>with_list</typeFlagsMask>
          <typeFlagsValue>with_list</typeFlagsValue>
          <content>
             /**                                                                                             \n
             * Definition of the callback function for @ref $(struct_prefix)_List_ForEachByType().           \n
             */                                                                                              \n
             typedef const $(struct_type)* ($(struct_type)_LIST_FOREACHBYTYPE_CB)(const $(struct_type) *element, void *user_data);
          </content>
        </inline>

        <inline loc="end" access="public">
          <typeFlagsMask>with_list</typeFlagsMask>
          <typeFlagsValue>with_list</typeFlagsValue>
          <content>
             /**                                                                                                       \n
              * Call the given callback function for every entry of the list which matches the given type and command. \n
              *                                                                                                        \n
              * @return Entry matching the description (or NULL if none)                                               \n
              * @param fn callback function to be called for every element of the given list                           \n
              * @param user_data user data forwarded to the callback function                                          \n
              * @param tl pointer to the list to search                                                                \n
              * @param ty transaction type, if 0 then this is not checked                                              \n
              * @param cmd command, if -1 then any non-zero command matches, if 0 then this is not checked             \n
             */                                                                                                        \n
             $(api) const $(struct_type) * $(struct_prefix)_List_ForEachByType(const $(struct_type)_LIST *tl,       
                                                                              $(struct_type)_LIST_FOREACHBYTYPE_CB fn,  
                                                                              void *user_data,                     
                                                                              int ty, int cmd);                    
          </content>
        </inline>

        <inline loc="code">
          <typeFlagsMask>with_list</typeFlagsMask>
          <typeFlagsValue>with_list</typeFlagsValue>
          <content>
             const $(struct_type) * $(struct_prefix)_List_ForEachByType(const $(struct_type)_LIST *tl,
                                                                        $(struct_type)_LIST_FOREACHBYTYPE_CB fn,
                                                                        void *user_data,                     
                                                                        int ty, int cmd) {
               if (tl) {
                 const $(struct_type) *t;

                 t=$(struct_prefix)_List_First(tl);
                 while(t) {
                   if ($(struct_prefix)_MatchTypeAndCommand(t, ty, cmd)) {
                     const $(struct_type) *tReturned;
                     
                     tReturned=fn(t, user_data);
                     if (tReturned)
                       return tReturned;
                   }
                   t=$(struct_prefix)_List_Next(t);
                 }
               }
               return NULL;
             }
          </content>
        </inline>



        <inline loc="end" access="public">
          <typeFlagsMask>with_list</typeFlagsMask>
          <typeFlagsValue>with_list</typeFlagsValue>
          <content>
             $(api) $(struct_type) * $(struct_prefix)_List_FindName(const $(struct_type)_LIST *tl, int ty, const char *ns, const char *n);
          </content>
        </inline>

        <inline loc="code">
          <typeFlagsMask>with_list</typeFlagsMask>
          <typeFlagsValue>with_list</typeFlagsValue>
          <content>
             $(struct_type) * $(struct_prefix)_List_FindName(const $(struct_type)_LIST *tl, int ty, const char *ns, const char *n) {
               if (tl) {
                 $(struct_type) *t;

                 t=$(struct_prefix)_List_First(tl);
                 while(t) {
                   if ( (ty==AB_Transaction_TypeNone || $(struct_prefix)_GetType(t)==ty) &amp;&amp;
                        (ns==NULL || 0==GWEN_Text_Compare(ns, t->unitIdNameSpace, 1))  &amp;&amp;
                        (n==NULL || 0==GWEN_Text_Compare(n, t->unitId, 1)) )
                     return t;

                   t=$(struct_prefix)_List_Next(t);
                 }
               }
               return NULL;
             }
          </content>
        </inline>


        <inline loc="end" access="public">
          <typeFlagsMask>with_list</typeFlagsMask>
          <typeFlagsValue>with_list</typeFlagsValue>
          <content>
             $(api) int $(struct_prefix)_List_WriteDb(const $(struct_type)_LIST *tl, GWEN_DB_NODE *db);
          </content>
        </inline>

        <inline loc="code">
          <typeFlagsMask>with_list</typeFlagsMask>
          <typeFlagsValue>with_list</typeFlagsValue>
          <content>
             int $(struct_prefix)_List_WriteDb(const $(struct_type)_LIST *tl, GWEN_DB_NODE *db) {
               if (tl) {
                 const $(struct_type) *t;

                 t=$(struct_prefix)_List_First(tl);
                 while(t) {
                   GWEN_DB_NODE *dbT;
                   int rv;

                   dbT=GWEN_DB_Group_new("transaction");
                   rv=AB_Transaction_WriteDb(t, dbT);
                   if (rv &lt; 0) {
                     DBG_ERROR(AQBANKING_LOGDOMAIN, "here (%d)", rv);
                     GWEN_DB_Group_free(dbT);
                     return rv;
                   }
                   else {
                     GWEN_DB_AddGroup(db, dbT);
                   }

                   t=$(struct_prefix)_List_Next(t);
                 }
               }
               return 0;
             }
          </content>
        </inline>


        <inline loc="end" access="public">
          <typeFlagsMask>with_list</typeFlagsMask>
          <typeFlagsValue>with_list</typeFlagsValue>
          <content>
             $(api) int $(struct_prefix)_List_ReadDb($(struct_type)_LIST *tl, GWEN_DB_NODE *db);
          </content>
        </inline>

        <inline loc="code">
          <typeFlagsMask>with_list</typeFlagsMask>
          <typeFlagsValue>with_list</typeFlagsValue>
          <content>
             int $(struct_prefix)_List_ReadDb($(struct_type)_LIST *tl, GWEN_DB_NODE *db) {
               if (tl &amp;&amp; db) {
                 GWEN_DB_NODE *dbT;

                 dbT=GWEN_DB_GetFirstGroup(db);
                 while(dbT) {
                   $(struct_type) *t;

                   t=$(struct_prefix)_fromDb(dbT);
                   if (t) {
                     $(struct_prefix)_List_Add(t, tl);
                   }

                   dbT=GWEN_DB_GetNextGroup(dbT);
                 }
               }
               else {
                 DBG_ERROR(AQBANKING_LOGDOMAIN, "Either list or db missing");
                 return GWEN_ERROR_INVALID;
               }
               return 0;
             }
          </content>
        </inline>


        <inline loc="end" access="public">
          <typeFlagsMask></typeFlagsMask>
          <typeFlagsValue></typeFlagsValue>
          <content>
             $(api) void $(struct_prefix)_AddPurposeLine($(struct_type) *t, const char *s);
          </content>
        </inline>

        <inline loc="code">
          <typeFlagsMask></typeFlagsMask>
          <typeFlagsValue></typeFlagsValue>
          <content>
             void $(struct_prefix)_AddPurposeLine($(struct_type) *t, const char *s) {
               assert(t);
               if (s &amp;&amp; *s) {
                 if (t->purpose &amp;&amp; *(t->purpose)) {
                   GWEN_BUFFER *tbuf;

                   tbuf=GWEN_Buffer_new(0, 256, 0, 1);
                   GWEN_Buffer_AppendString(tbuf, t->purpose);
                   GWEN_Buffer_AppendString(tbuf, "\\n");
                   GWEN_Buffer_AppendString(tbuf, s);
                   $(struct_prefix)_SetPurpose(t, GWEN_Buffer_GetStart(tbuf));
                   GWEN_Buffer_free(tbuf);
                 }
                 else
                   $(struct_prefix)_SetPurpose(t, s);
               }
               else {
                 DBG_ERROR(AQBANKING_LOGDOMAIN, "Not adding empty string");
               }
             }
          </content>
        </inline>


        <inline loc="end" access="public">
          <typeFlagsMask></typeFlagsMask>
          <typeFlagsValue></typeFlagsValue>
          <content>
             $(api) void $(struct_prefix)_SetPurposeFromStringList($(struct_type) *t, const GWEN_STRINGLIST *sl);
          </content>
        </inline>

        <inline loc="code">
          <typeFlagsMask></typeFlagsMask>
          <typeFlagsValue></typeFlagsValue>
          <content>
             void $(struct_prefix)_SetPurposeFromStringList($(struct_type) *t, const GWEN_STRINGLIST *sl) {
               assert(t);
               if (sl) {
                 GWEN_STRINGLISTENTRY *se;
                 GWEN_BUFFER *tbuf;

                 tbuf=GWEN_Buffer_new(0, 256, 0, 1);
                 se=GWEN_StringList_FirstEntry(sl);
                 while(se) {
                   const char *s;

                   s=GWEN_StringListEntry_Data(se);
                   if (s &amp;&amp; *s) {
                     if (GWEN_Buffer_GetUsedBytes(tbuf))
                       GWEN_Buffer_AppendString(tbuf, "\\n");
                     GWEN_Buffer_AppendString(tbuf, s);
                   }
                   se=GWEN_StringListEntry_Next(se);
                 }

                 $(struct_prefix)_SetPurpose(t, GWEN_Buffer_GetStart(tbuf));
                 GWEN_Buffer_free(tbuf);
               }
               else {
                 $(struct_prefix)_SetPurpose(t, NULL);
               }
             }
          </content>
        </inline>



        <inline loc="end" access="public">
          <typeFlagsMask></typeFlagsMask>
          <typeFlagsValue></typeFlagsValue>
          <content>
             /**                                                                                                 \n
             * The purpose fields may contain multiple purpose lines separated by a NEWLINE character (10).      \n
             * If you need the old behaviour of previous versions you can use this function to get a string list \n
             * representation of the purpose lines.                                                              \n
             *                                                                                                   \n
             * If the purpose field is empty NULL is returned (no empty list is ever returned).                  \n
             *                                                                                                   \n
             * The caller is responsible for freeing the object returned, if any.                                \n
             *                                                                                                   \n
             * @return stringlist (NULL if empty)                                                                \n
             * @param t transaction object                                                                       \n
             */                                                                                                  \n
             $(api) GWEN_STRINGLIST *$(struct_prefix)_GetPurposeAsStringList(const $(struct_type) *t);
          </content>
        </inline>

        <inline loc="code">
          <typeFlagsMask></typeFlagsMask>
          <typeFlagsValue></typeFlagsValue>
          <content>
             GWEN_STRINGLIST *$(struct_prefix)_GetPurposeAsStringList(const $(struct_type) *t) {
               const char *s;
               assert(t);
               
               s=$(struct_prefix)_GetPurpose(t);
               if (s &amp;&amp; *s) {
                 GWEN_STRINGLIST *stringList;
             
                 stringList=GWEN_StringList_fromString(s, "\\n", 0);
                 return stringList;
               }
               
               return NULL;
             }
          </content>
        </inline>



        <inline loc="end" access="public">
          <typeFlagsMask></typeFlagsMask>
          <typeFlagsValue></typeFlagsValue>
          <content>
             $(api) void $(struct_prefix)_AddCategory($(struct_type) *t, const char *s);
          </content>
        </inline>

        <inline loc="code">
          <typeFlagsMask></typeFlagsMask>
          <typeFlagsValue></typeFlagsValue>
          <content>
             void $(struct_prefix)_AddCategory($(struct_type) *t, const char *s) {
               assert(t);
               if (s &amp;&amp; *s) {
                 if (t->category &amp;&amp; *(t->category)) {
                   GWEN_BUFFER *tbuf;

                   tbuf=GWEN_Buffer_new(0, 256, 0, 1);
                   GWEN_Buffer_AppendString(tbuf, t->category);
                   GWEN_Buffer_AppendString(tbuf, "\\n");
                   GWEN_Buffer_AppendString(tbuf, s);
                   $(struct_prefix)_SetPurpose(t, GWEN_Buffer_GetStart(tbuf));
                   GWEN_Buffer_free(tbuf);
                 }
                 else
                   $(struct_prefix)_SetCategory(t, s);
               }
               else {
                 DBG_ERROR(AQBANKING_LOGDOMAIN, "Not adding empty string");
               }
             }
          </content>
        </inline>


        <inline loc="end" access="public">
          <typeFlagsMask></typeFlagsMask>
          <typeFlagsValue></typeFlagsValue>
          <content>
             $(api) void $(struct_prefix)_SetCategoryFromStringList($(struct_type) *t, const GWEN_STRINGLIST *sl);
          </content>
        </inline>

        <inline loc="code">
          <typeFlagsMask></typeFlagsMask>
          <typeFlagsValue></typeFlagsValue>
          <content>
             void $(struct_prefix)_SetCategoryFromStringList($(struct_type) *t, const GWEN_STRINGLIST *sl) {
               assert(t);
               if (sl) {
                 GWEN_STRINGLISTENTRY *se;
                 GWEN_BUFFER *tbuf;

                 tbuf=GWEN_Buffer_new(0, 256, 0, 1);
                 se=GWEN_StringList_FirstEntry(sl);
                 while(se) {
                   const char *s;

                   s=GWEN_StringListEntry_Data(se);
                   if (s &amp;&amp; *s) {
                     if (GWEN_Buffer_GetUsedBytes(tbuf))
                       GWEN_Buffer_AppendString(tbuf, "\\n");
                     GWEN_Buffer_AppendString(tbuf, s);
                   }
                   se=GWEN_StringListEntry_Next(se);
                 }

                 $(struct_prefix)_SetCategory(t, GWEN_Buffer_GetStart(tbuf));
                 GWEN_Buffer_free(tbuf);
               }
               else {
                 $(struct_prefix)_SetCategory(t, NULL);
               }
             }
          </content>
        </inline>


        <inline loc="end" access="public">
          <typeFlagsMask>with_list2</typeFlagsMask>
          <typeFlagsValue>with_list2</typeFlagsValue>
          <content>
             $(api) int $(struct_prefix)_List2_freeAll($(struct_type)_LIST2 *tl);
          </content>
        </inline>

        <inline loc="code">
          <typeFlagsMask>with_list2</typeFlagsMask>
          <typeFlagsValue>with_list2</typeFlagsValue>
          <content>

             static $(struct_type) *$(struct_prefix)_List2__freeAll_cb($(struct_type) *t, void *user_data) {
               $(struct_prefix)_free(t);
               return NULL;
             }


             int $(struct_prefix)_List2_freeAll($(struct_type)_LIST2 *tl) {
               if (tl) {
                 $(struct_prefix)_List2_ForEach(tl, $(struct_prefix)_List2__freeAll_cb, NULL);
                 $(struct_prefix)_List2_free(tl);
               }
               else {
                 DBG_ERROR(AQBANKING_LOGDOMAIN, "List missing");
                 return GWEN_ERROR_INVALID;
               }
               return 0;
             }
          </content>
        </inline>


      </inlines>

    </lang>

    <enums>

      <enum id="AB_TRANSACTION_TYPE" prefix="AB_Transaction_Type" type="AB_TRANSACTION_TYPE">
        <item name="none"                value="0" />

        <!-- bank statements, balances, account specs etc -->
        <item name="statement"           value="128"/>
        <item name="notedStatement"/>

        <!-- transfers, debit notes, standing orders -->
        <item name="transfer"            value="256"/>
        <item name="debitNote"/>
        <item name="standingOrder"/>
        <item name="internalTransfer"/>
        <item name="brokerage"/>

        <!-- double entry bookkeeping -->
        <item name="transaction"         value="2048"/>
        <item name="split"/>

      </enum>


      <enum id="AB_TRANSACTION_SUBTYPE" prefix="AB_Transaction_SubType" type="AB_TRANSACTION_SUBTYPE">
        <item name="none"                value="0" />
        <item name="standard"/>
        <item name="check"/>
        <item name="bookedDebitNote"/>
        <item name="drawnDebitNote"/>
        <item name="standingOrder"/>
        <item name="loan"/>
        <item name="euStandard"/>
        <item name="euASAP"/>
        <item name="buy"/>
        <item name="sell"/>
        <item name="reinvest"/>
        <item name="dividend"/>
      </enum>


      <enum id="AB_TRANSACTION_COMMAND" prefix="AB_Transaction_Command" type="AB_TRANSACTION_COMMAND">
        <item name="none"                value="0"/>

        <item name="getBalance"/>
        <item name="getTransactions"/>
        <item name="getStandingOrders"/>
        <item name="getDatedTransfers"/>
        <item name="sepaGetStandingOrders"/>

        <item name="loadCellPhone"/>

        <item name="getEStatements"/>


        <!-- Bit 8 set: transfer jobs, bit 9 cleared: non-SEPA -->
        <item name="transfer"            value="512"/>
        <item name="debitNote"/>

        <item name="createStandingOrder"/>
        <item name="modifyStandingOrder"/>
        <item name="deleteStandingOrder"/>

        <item name="createDatedTransfer"/>
        <item name="modifyDatedTransfer"/>
        <item name="deleteDatedTransfer"/>

        <item name="internalTransfer"/>

        <item name="getDepot"/>

        <!-- Bit 8 set: transfer jobs, bit 9 set: SEPA -->
        <item name="sepaTransfer"        value="1536"/>
        <item name="sepaDebitNote"/>

        <item name="sepaFlashDebitNote"/>
        <item name="sepaCreateStandingOrder"/>
        <item name="sepaModifyStandingOrder"/>
        <item name="sepaDeleteStandingOrder"/>

        <item name="sepaCreateDatedTransfer"/>
        <item name="sepaModifyDatedTransfer"/>
        <item name="sepaDeleteDatedTransfer"/>

        <item name="sepaInternalTransfer"/>

      </enum>


      <enum id="AB_TRANSACTION_STATUS" prefix="AB_Transaction_Status" type="AB_TRANSACTION_STATUS">
        <item name="none" value="0"/>
        <item name="enqueued"/>
        <item name="sending"/>
        <item name="sent"/>

        <item name="accepted"/>
        <item name="rejected"/>
        <item name="pending"/>
        
        <item name="autoReconciled"/>
        <item name="manuallyReconciled"/>
        
        <item name="revoked"/>
        <item name="aborted"/>

        <item name="error"/>
      </enum>

      <enum id="AB_TRANSACTION_PERIOD" prefix="AB_Transaction_Period" type="AB_TRANSACTION_PERIOD">
        <item name="none" value="0"/>
        <item name="monthly"/>
        <item name="weekly"/>
      </enum>

      <enum id="AB_TRANSACTION_CHARGE" prefix="AB_Transaction_Charge" type="AB_TRANSACTION_CHARGE">
        <item name="nobody" value="0"/>
        <item name="local"/>
        <item name="remote"/>
        <item name="share"/>
      </enum>

      <enum id="AB_TRANSACTION_SEQUENCE" prefix="AB_Transaction_Sequence" type="AB_TRANSACTION_SEQUENCE">
        <item name="once" value="0"/>
        <item name="first"/>
        <item name="following"/>
        <item name="final"/>
      </enum>

      <enum id="AB_TRANSACTION_ACK" prefix="AB_Transaction_Ack" type="AB_TRANSACTION_ACK">
        <item name="never" value="0"/>
        <item name="jobsWithAckCode"/>
      </enum>

    </enums>

    <defines>

    </defines>

  <!--
    <typedefs>
      <typedef id="AE_STATEMENT_FLAGS" prefix="AE_Statement_Flags">
     </typedef>
    </typedefs>
   -->

    <members>

      <group title="Type, Command, Status" >

        <member name="type" type="int" maxlen="32" enum="AB_TRANSACTION_TYPE" >
          <default>AB_Transaction_TypeUnknown</default>
          <preset>AB_Transaction_TypeUnknown</preset>
          <access>public</access>
          <flags>enum with_hash</flags>
          <setflags>none</setflags>
          <getflags>none</getflags>
        </member>

        <member name="subType" type="int" maxlen="32" enum="AB_TRANSACTION_SUBTYPE" >
          <default>AB_Transaction_SubTypeNone</default>
          <preset>AB_Transaction_SubTypeNone</preset>
          <access>public</access>
          <flags>enum with_hash</flags>
          <setflags>none</setflags>
          <getflags>none</getflags>
        </member>

        <member name="command" type="int" maxlen="32" enum="AB_TRANSACTION_COMMAND" >
          <default>AB_Transaction_CommandNone</default>
          <preset>AB_Transaction_CommandNone</preset>
          <access>public</access>
          <flags>enum with_hash</flags>
          <setflags>none</setflags>
          <getflags>none</getflags>
        </member>

        <member name="status" type="int" maxlen="32" enum="AB_TRANSACTION_STATUS" >
          <default>AB_Transaction_StatusUnknown</default>
          <preset>AB_Transaction_StatusUnknown</preset>
          <access>public</access>
          <flags>enum with_hash</flags>
          <setflags>none</setflags>
          <getflags>none</getflags>
        </member>

        <member name="uniqueAccountId" type="uint32_t" maxlen="4">
          <default>0</default>
          <preset>0</preset>
          <access>public</access>
          <flags>with_hash</flags>
          <descr>
            This is a unique id of the local account for banking commands.
          </descr>
        </member>

        <member name="acknowledge" type="int" maxlen="32" enum="AB_TRANSACTION_ACK" >
          <default>AB_Transaction_AckNever</default>
          <preset>AB_Transaction_AckNever</preset>
          <access>public</access>
          <flags>enum with_hash</flags>
          <setflags>none</setflags>
          <getflags>none</getflags>
        </member>

      </group>


      <group title="Identifiers" >
        <member name="uniqueId" type="uint32_t" maxlen="4">
          <default>0</default>
          <preset>0</preset>
          <access>public</access>
          <flags>with_hash with_getbymember</flags>
          <descr>
            This is a unique id assigned by the application. However, when
            adding a transaction to a job (like JobTransfer) this id is
            assigned by AqBanking to make sure that this id is unique across
            all applications.
          </descr>
        </member>

        <member name="refUniqueId" type="uint32_t" maxlen="4">
          <default>0</default>
          <preset>0</preset>
          <access>public</access>
          <flags>with_hash</flags>
          <descr>
            This id is used in splits to refer to the transaction id the split
            belongs to.
            It is also used internally by backends when on job is linked to another one.
          </descr>
        </member>

        <member name="idForApplication" type="uint32_t">
          <default>0</default>
          <preset>0</preset>
          <access>public</access>
          <flags>with_hash with_getbymember</flags>
          <descr>
            This is an id assigned by the application only.
            This id is never changed by AqBanking.
          </descr>
        </member>


        <member name="stringIdForApplication" type="char_ptr" maxlen="64">
          <default>0</default>
          <preset>0</preset>
          <access>public</access>
          <flags>with_hash with_getbymember</flags>
          <descr>
            This is an id assigned by the application only.
            This id is never changed by AqBanking.
          </descr>
        </member>

        <member name="sessionId" type="uint32_t" maxlen="4">
          <default>0</default>
          <preset>0</preset>
          <access>public</access>
          <flags>with_hash</flags>
          <descr>
            This id can be used by applications, e.g. to group jobs into sessions.
          </descr>
        </member>

        <member name="groupId" type="uint32_t" >
          <default>0</default>
          <preset>0</preset>
          <access>public</access>
          <flags>with_hash</flags>
          <descr>
            This id is assigned by a backend when sending multiple transfer
            jobs in one backend request (e.g. AqHBCI uses DTAUS files when sending
            multi-transfer requests; in this case every transfer which goes
            into the same DTAUS file receives the same group id).
          </descr>
        </member>

        <member name="fiId" type="char_ptr" maxlen="32" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <descr>
            <p>
              This id is assigned by the bank. As for the moment only OFX servers actually do
              assign unique ids to statements.
            </p>
            <p>
              However, HBCI servers at least assign unique ids to standing orders and dated transfers.
            </p>
          </descr>
        </member>

      </group>



      <group title="Local Account Specification" >
        <descr>
          <p>
            Properties of this group specify the local account to be used for
            this transaction.
          </p>
          <p>
            Accounts are usually specified in one of two ways:
          </p>
          <ul>
            <li>SEPA: IBAN and BIC</li>
            <li>non-SEPA: Bank account and Account number</li>
          </ul>
        </descr>

        <group title="SEPA">
          <member name="localIban" type="char_ptr" maxlen="32" >
            <access>public</access>
            <flags>own with_hash</flags>
            <setflags>const dup</setflags>
            <getflags>const</getflags>
          </member>

          <member name="localBic" type="char_ptr" maxlen="16" >
            <access>public</access>
            <flags>own with_hash</flags>
            <setflags>const dup</setflags>
            <getflags>const</getflags>
          </member>
        </group>

        <group title="Non-SEPA">
          <member name="localCountry" type="char_ptr" maxlen="16" >
            <access>public</access>
            <flags>own with_hash</flags>
            <setflags>const dup</setflags>
            <getflags>const</getflags>
          </member>

          <member name="localBankCode" type="char_ptr" maxlen="16" >
            <access>public</access>
            <flags>own with_hash</flags>
            <setflags>const dup</setflags>
            <getflags>const</getflags>
          </member>

          <member name="localBranchId" type="char_ptr" maxlen="32">
            <access>public</access>
            <flags>own with_hash</flags>
            <setflags>const dup</setflags>
            <getflags>const</getflags>
            <descr>
             This is the branch id of the local bank (OFX only)
            </descr>
          </member>

          <member name="localAccountNumber" type="char_ptr" maxlen="32" >
            <access>public</access>
            <flags>own with_hash</flags>
            <setflags>const dup</setflags>
            <getflags>const</getflags>
          </member>

          <member name="localSuffix" type="char_ptr" maxlen="16" >
            <access>public</access>
            <flags>own with_hash</flags>
            <setflags>const dup</setflags>
            <getflags>const</getflags>
            <descr>
              If your account has subaccounts which are distinguished by
              different suffixes, then this is that suffix. Otherwise it's
              empty. (HBCI only)
            </descr>
          </member>

        </group>

        <member name="localName" type="char_ptr" maxlen="64" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
        </member>

      </group>


      <group title="Remote Account Specification" >
        <descr>
          <p>
            Properties of this group specify the remote account to be used for
            this transaction.
          </p>
        </descr>

        <member name="remoteCountry" type="char_ptr" maxlen="16" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
        </member>

        <member name="remoteBankCode" type="char_ptr" maxlen="16" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
        </member>

        <member name="remoteBranchId" type="char_ptr" maxlen="32">
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <descr>
           This is the branch id of the remote bank (OFX only)
          </descr>
        </member>

        <member name="remoteAccountNumber" type="char_ptr" maxlen="32" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
        </member>

        <member name="remoteSuffix" type="char_ptr" maxlen="16" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <descr>
            Same as localSuffix, except for remote account (HBCI only).
          </descr>
        </member>

        <member name="remoteIban" type="char_ptr" maxlen="32" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
        </member>

        <member name="remoteBic" type="char_ptr" maxlen="16" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
        </member>

        <member name="remoteName" type="char_ptr" maxlen="64" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
        </member>
      </group>



      <group title="Dates" >
        <member name="date" type="gwen_date" maxlen="16" >
          <aqdb_type>AQDB_DataType_String</aqdb_type>
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <default>NULL</default>
          <preset>NULL</preset>
        </member>

        <member name="valutaDate" type="gwen_date" maxlen="16" >
          <aqdb_type>AQDB_DataType_String</aqdb_type>
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <default>NULL</default>
          <preset>NULL</preset>
        </member>
      </group>


      <group title="Amount">
        <member name="value" type="AB_VALUE" maxlen="256" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <default>NULL</default>
          <preset>NULL</preset>
        </member>

        <member name="fees" type="AB_VALUE" maxlen="256" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <default>NULL</default>
          <preset>NULL</preset>
        </member>

      </group>


      <group title="Info Texts and Codes">

        <member name="transactionCode" type="int" >
          <default>0</default>
          <preset>0</preset>
          <access>public</access>
          <flags>with_hash</flags>
          <descr>
            A 3 digit numerical transaction code, defined for all kinds of
            different actions. (Geschaeftsvorfallcode)
          </descr>
        </member>

        <member name="transactionText" type="char_ptr" maxlen="32" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <descr>
            Transaction text (e.g. STANDING ORDER) (Buchungstext)
          </descr>
        </member>

        <member name="transactionKey" type="char_ptr" maxlen="32" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <descr>
            this is the transaction id that tells you more about the type
            of transaction (3 character code) (Buchungsschluessel)
            (HBCI only)
          </descr>
        </member>

        <member name="textKey" type="int" >
          <default>0</default>
          <preset>0</preset>
          <access>public</access>
          <flags>with_hash</flags>
          <descr>
            <p>
              A numerical transaction code, defined for all kinds of
              different actions. (Textschluessel)
            </p>
            <p>
              For a normal transfer you should set it to 51. For debit notes
              the values 04 or 05 may be used. For other values please refer to
              your credit institute. (HBCI only)
            </p>
          </descr>
        </member>

        <member name="primanota" type="char_ptr" maxlen="32">
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <descr>
            Used for SEPA transfers.
          </descr>
        </member>

        <member name="purpose" type="char_ptr" maxlen="256" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <descr>
            A list of purpose lines, separated by newline characters.
          </descr>
        </member>

        <member name="category" type="char_ptr" maxlen="256" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <descr>
            A list of categories assigned to this transaction, separated by newline characters.
          </descr>
        </member>

      </group>



      <group title="References">
        <member name="customerReference" type="char_ptr" maxlen="32" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <descr>
            Reference string, if the customer (you) has specified
            one. (E.g. the cheque number.) Otherwise "NONREF" or empty
            (Kundenreferenz)
          </descr>
        </member>

        <member name="bankReference" type="char_ptr" maxlen="32" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <descr>
            Reference string for this transaction given by the bank, if it
            has given one. Otherwise empty. (Bankreferenz)
          </descr>
        </member>
      </group>



      <group title="Additional Data for SEPA Transactions">

        <descr>
          <p>These properties are only used in SEPA statements or transactions.</p>
        </descr>

        <member name="endToEndReference" type="char_ptr" maxlen="64" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <descr>
            This is a reference provided by the issuer of a SEPA transfer.
          </descr>
        </member>

        <member name="ultimateCreditor" type="char_ptr" maxlen="64" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <descr>
            "Abweichender Empfaenger" (ABWE+).
          </descr>
        </member>

        <member name="ultimateDebtor" type="char_ptr" maxlen="64" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <descr>
            "Abweichender Auftraggeber" (ABWA+).
          </descr>
        </member>


        <group title="Additional Data for SEPA Debit Notes">

          <descr>
            <p>These properties are only used in SEPA statements or transactions.</p>
          </descr>

          <member name="creditorSchemeId" type="char_ptr" maxlen="32">
            <access>public</access>
            <flags>own with_hash</flags>
            <setflags>const dup</setflags>
            <getflags>const</getflags>
            <descr>
              Creditor Scheme Identification" ("Glaeubiger-ID", assigned by Deutsche Bundesbank).
            </descr>
          </member>

          <member name="originatorId" type="char_ptr" maxlen="32">
            <access>public</access>
            <flags>own with_hash</flags>
            <setflags>const dup</setflags>
            <getflags>const</getflags>
            <descr>
            </descr>
          </member>

          <member name="mandateId" type="char_ptr" maxlen="32">
            <access>public</access>
            <flags>own with_hash</flags>
            <setflags>const dup</setflags>
            <getflags>const</getflags>
            <descr>
              SEPA Direct debit mandate id.
            </descr>
          </member>

          <member name="mandateDate" type="gwen_date" maxlen="16" >
            <aqdb_type>AQDB_DataType_String</aqdb_type>
            <access>public</access>
            <flags>own with_hash</flags>
            <setflags>const dup</setflags>
            <getflags>const</getflags>
            <default>NULL</default>
            <preset>NULL</preset>
            <descr>
              Issue date of the direct debit mandate.
            </descr>
          </member>

          <member name="mandateDebitorName" type="char_ptr" maxlen="32">
            <access>public</access>
            <flags>own with_hash</flags>
            <setflags>const dup</setflags>
            <getflags>const</getflags>
            <descr>
              Debitor name for direct debit mandate if given by the debitor.
            </descr>
          </member>

          <member name="originalCreditorSchemeId" type="char_ptr" maxlen="32">
            <access>public</access>
            <flags>own with_hash</flags>
            <setflags>const dup</setflags>
            <getflags>const</getflags>
            <descr>
              Original value for "Creditor Scheme Identification", in case that value changed over time.
            </descr>
          </member>

          <member name="originalMandateId" type="char_ptr" maxlen="32">
            <access>public</access>
            <flags>own with_hash</flags>
            <setflags>const dup</setflags>
            <getflags>const</getflags>
            <descr>
              Original SEPA Direct debit mandate id, in case that changed over time.
            </descr>
          </member>

          <member name="originalCreditorName" type="char_ptr" maxlen="32">
            <access>public</access>
            <flags>own with_hash</flags>
            <setflags>const dup</setflags>
            <getflags>const</getflags>
            <descr>
              Original SEPA Direct debit creditor name, in case that changed over time.
            </descr>
          </member>

          <member name="sequence" type="int" maxlen="32" enum="AB_TRANSACTION_SEQUENCE" >
            <default>AB_Transaction_SequenceUnknown</default>
            <preset>AB_Transaction_SequenceUnknown</preset>
            <access>public</access>
            <flags>enum with_hash</flags>
            <setflags>none</setflags>
            <getflags>none</getflags>
          </member>
        </group>

        <member name="charge" type="int" maxlen="32" enum="AB_TRANSACTION_CHARGE" >
          <default>AB_Transaction_ChargeUnknown</default>
          <preset>AB_Transaction_ChargeUnknown</preset>
          <access>public</access>
          <flags>enum with_hash</flags>
          <setflags>none</setflags>
          <getflags>none</getflags>
        </member>
      </group>

      <group title="Additional Information for Foreign Transfers" >
        <descr>
          <p>
            This group contains information which is used with transfers to
            other countries in the world.
            It is used by backends and applications but not by AqBanking itself.
          </p>
        </descr>

          <member name="remoteAddrStreet" type="char_ptr" maxlen="64">
            <access>public</access>
            <flags>own with_hash</flags>
            <setflags>const dup</setflags>
            <getflags>const</getflags>
            <descr>
              Street and number.
            </descr>
          </member>

          <member name="remoteAddrZipcode" type="char_ptr" maxlen="16">
            <access>public</access>
            <flags>own with_hash</flags>
            <setflags>const dup</setflags>
            <getflags>const</getflags>
            <descr>
              Zipcode.
            </descr>
          </member>

          <member name="remoteAddrCity" type="char_ptr" maxlen="64">
            <access>public</access>
            <flags>own with_hash</flags>
            <setflags>const dup</setflags>
            <getflags>const</getflags>
            <descr>
              City.
            </descr>
          </member>

          <member name="remoteAddrPhone" type="char_ptr" maxlen="64">
            <access>public</access>
            <flags>own with_hash</flags>
            <setflags>const dup</setflags>
            <getflags>const</getflags>
            <descr>
              Phone number.
            </descr>
          </member>

      </group>


      <group title="Additional Data for Standing Orders">

        <descr>
          <p>
            These properties are used with standing orders, i.e. orders which are regularily
            repeated by the bank.
          </p>
        </descr>

        <member name="period" type="int" maxlen="32" enum="AB_TRANSACTION_PERIOD" >
          <default>AB_Transaction_PeriodUnknown</default>
          <preset>AB_Transaction_PeriodUnknown</preset>
          <access>public</access>
          <flags>enum with_hash</flags>
          <setflags>none</setflags>
          <getflags>none</getflags>
        </member>

        <member name="cycle" type="uint32_t" maxlen="4">
          <default>0</default>
          <preset>0</preset>
          <access>public</access>
          <flags>with_hash</flags>
          <descr>
            The standing order is executed every <i>cycle</i> x <i>period</i>.
            So if <i>period</i> is <i>weekly</i> and <i>cycle</i> is <i>2</i>
            then the standing order is executed every 2 weeks.
          </descr>
        </member>

        <member name="executionDay" type="uint32_t" maxlen="4">
          <default>0</default>
          <preset>0</preset>
          <access>public</access>
          <flags>with_hash</flags>
          <descr>
            The execution day. The meaning of this variable depends on the
            content of <i>period</i>:
            <ul>
              <li>monthly: day of the month (starting with <i>1</i>)</li>
              <li>weekly: day of the week (starting with <i>1</i>=Monday)</li>
            </ul>
          </descr>
        </member>

        <member name="firstDate" type="gwen_date" maxlen="16" >
          <aqdb_type>AQDB_DataType_String</aqdb_type>
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <default>NULL</default>
          <preset>NULL</preset>
          <descr>
            For standing orders this is the first date the transaction is to be executed.
            For jobs which use date span parameters this is the first date
            (e.g. "get statements from FIRSTDATE to LASTDATE)"
          </descr>
        </member>

        <member name="lastDate" type="gwen_date" maxlen="16" >
          <aqdb_type>AQDB_DataType_String</aqdb_type>
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <default>NULL</default>
          <preset>NULL</preset>
          <descr>
            For standing orders this is the last date the transaction is to be executed.
            For jobs which use date span parameters this is the last date
            (e.g. "get statements from FIRSTDATE to LASTDATE)"
          </descr>
        </member>

        <member name="nextDate" type="gwen_date" maxlen="16" >
          <aqdb_type>AQDB_DataType_String</aqdb_type>
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <default>NULL</default>
          <preset>NULL</preset>
          <descr>
            For standing orders this is the next date the transaction is executed.
          </descr>
        </member>

      </group>


      <group title="Additional Data for Securites">

        <descr>
          <p>
            These properties are used with securities.
          </p>
        </descr>

        <member name="unitId" type="char_ptr" maxlen="128" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <descr>
            Unique id of the security within the namespace. This field is also used with accounts.
          </descr>
        </member>


        <member name="unitIdNameSpace" type="char_ptr" maxlen="128" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <descr>
            Namespace for name (e.g. CUSIP for North America)
          </descr>
        </member>

        <member name="tickerSymbol" type="char_ptr" maxlen="128" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <descr>
            Unique id of the security within the namespace.
          </descr>
        </member>

        <member name="units" type="AB_VALUE" maxlen="256" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <default>NULL</default>
          <preset>NULL</preset>
        </member>

        <member name="unitPriceValue" type="AB_VALUE" maxlen="256" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <default>NULL</default>
          <preset>NULL</preset>
        </member>


        <member name="unitPriceDate" type="gwen_date" maxlen="16" >
          <aqdb_type>AQDB_DataType_String</aqdb_type>
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <default>NULL</default>
          <preset>NULL</preset>
          <descr>
            Date of the unit price.
          </descr>
        </member>

        <member name="commissionValue" type="AB_VALUE" maxlen="256" >
          <access>public</access>
          <flags>own with_hash</flags>
          <setflags>const dup</setflags>
          <getflags>const</getflags>
          <default>NULL</default>
          <preset>NULL</preset>
        </member>


      </group>

      <group title="Additional Data for Estatements">

        <descr>
          <p>These properties are only used in estatement requests.</p>
        </descr>

        <member name="estatementNumber" type="uint32_t" maxlen="4">
          <default>0</default>
          <preset>0</preset>
          <access>public</access>
          <flags>with_hash</flags>
	  <descr>
            To select a specific estatment document.
            Estatements are numbered increasingly, starting over at number 1 each year.
            Year can be given by additionally setting startDate. If no year is given,
            the current year is taken as base.
            0 means no specific selection, return all.
          </descr>
        </member>

        <member name="estatementMaxEntries" type="uint32_t" maxlen="4">
          <default>0</default>
          <preset>0</preset>
          <access>public</access>
          <flags>with_hash</flags>
          <descr>
            How many estatements to retrieve at most with this transaction.
          </descr>
        </member>


      </group>


      <member name="memo" type="char_ptr" maxlen="1024" >
        <access>public</access>
        <flags>own with_hash</flags>
        <setflags>const dup</setflags>
        <getflags>const</getflags>
        <descr>
          User-defined memo.
        </descr>
      </member>




      <member name="hash" type="char_ptr" maxlen="64" >
        <access>public</access>
        <flags>own volatile</flags>
        <setflags>const dup</setflags>
        <getflags>const</getflags>
      </member>


    </members>


  </type>

</tm2>

